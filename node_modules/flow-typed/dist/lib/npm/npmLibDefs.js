"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._validateVersionPart = exports._validateVersionNumPart = exports._parsePkgNameVer = exports._extractLibDefsFromNpmPkgDir = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.findNpmLibDef = findNpmLibDef;
exports.getInstalledNpmLibDefs = getInstalledNpmLibDefs;
exports.getNpmLibDefs = getNpmLibDefs;
exports.getNpmLibDefVersionHash = getNpmLibDefVersionHash;

var _cacheRepoUtils = require("../cacheRepoUtils");

var _codeSign = require("../codeSign");

var _fileUtils = require("../fileUtils");

var _flowVersion2 = require("../flowVersion");

var _git = require("../git");

var _node = require("../node");

var _semver = require("../semver");

var _semver2 = require("semver");

var _semver3 = _interopRequireDefault(_semver2);

var _validationErrors = require("../validationErrors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var P = Promise;

var TEST_FILE_NAME_RE = /^test_.*\.js$/;

function extractLibDefsFromNpmPkgDir(pkgDirPath, scope, pkgNameVer, validationErrors) {
  var _this = this;

  var errContext, parsedPkgNameVer, pkgName, pkgVersion, npmDefsDirPath, pkgVersionStr, libDefFileName, pkgDirItems, commonTestFiles, parsedFlowDirs, libDefs;
  return regeneratorRuntime.async(function extractLibDefsFromNpmPkgDir$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          errContext = "npm/" + (scope === null ? '' : scope + '/') + pkgNameVer;
          parsedPkgNameVer = parsePkgNameVer(pkgNameVer, errContext, validationErrors);

          if (!(parsedPkgNameVer === null)) {
            _context2.next = 4;
            break;
          }

          return _context2.abrupt("return", []);

        case 4:
          pkgName = parsedPkgNameVer.pkgName, pkgVersion = parsedPkgNameVer.pkgVersion;
          npmDefsDirPath = scope === null ? _node.path.resolve(pkgDirPath, '..') : _node.path.resolve(pkgDirPath, '..', '..');
          pkgVersionStr = (0, _semver.versionToString)(pkgVersion);
          libDefFileName = pkgName + "_" + pkgVersionStr + ".js";
          _context2.next = 10;
          return regeneratorRuntime.awrap(_node.fs.readdir(pkgDirPath));

        case 10:
          pkgDirItems = _context2.sent;
          commonTestFiles = [];
          parsedFlowDirs = [];

          pkgDirItems.forEach(function (pkgDirItem) {
            var pkgDirItemPath = _node.path.join(pkgDirPath, pkgDirItem);
            var pkgDirItemContext = _node.path.relative(npmDefsDirPath, pkgDirItemPath);

            var pkgDirItemStat = _node.fs.statSync(pkgDirItemPath);
            if (pkgDirItemStat.isFile()) {
              if (_node.path.extname(pkgDirItem) === ".swp") {
                return;
              }

              var isValidTestFile = TEST_FILE_NAME_RE.test(pkgDirItem);

              if (isValidTestFile) {
                commonTestFiles.push(pkgDirItemPath);
                return;
              }

              var error = "Unexpected file name. This directory can only contain test files " + ("or a libdef file named " + ('`' + libDefFileName + '`') + ".");
              (0, _validationErrors.validationError)(pkgDirItemContext, error, validationErrors);
            } else if (pkgDirItemStat.isDirectory()) {
              var errCount = validationErrors == null ? 0 : validationErrors.size;
              var parsedFlowDir = (0, _flowVersion2.parseDirString)(pkgDirItem, pkgNameVer + "/" + pkgDirItem, validationErrors);
              // If parsing a flow directory incurred a validation error, don't keep it
              // around in our list of parsed flow directories
              // TODO: Make the parseFlowDirString API return `null` when there's an
              //       error
              if (validationErrors != null && errCount !== validationErrors.size) {
                return;
              }
              parsedFlowDirs.push([pkgDirItemPath, parsedFlowDir]);
            } else {
              var _error = "Unexpected directory item";
              (0, _validationErrors.validationError)(pkgDirItemContext, _error, validationErrors);
            }
          });

          if (!(0, _flowVersion2.disjointVersionsAll)(parsedFlowDirs.map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                _ = _ref2[0],
                ver = _ref2[1];

            return ver;
          }))) {
            (0, _validationErrors.validationError)(errContext, "Flow versions not disjoint!", validationErrors);
          }

          if (parsedFlowDirs.length === 0) {
            (0, _validationErrors.validationError)(errContext, 'No libdef files found!', validationErrors);
          }

          libDefs = [];
          _context2.next = 19;
          return regeneratorRuntime.awrap(P.all(parsedFlowDirs.map(function _callee(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                flowDirPath = _ref4[0],
                flowVersion = _ref4[1];

            var testFilePaths, libDefFilePath, error;
            return regeneratorRuntime.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    testFilePaths = [].concat(commonTestFiles);
                    libDefFilePath = null;
                    _context.next = 4;
                    return regeneratorRuntime.awrap(_node.fs.readdir(flowDirPath));

                  case 4:
                    _context.t0 = function (flowDirItem) {
                      var flowDirItemPath = _node.path.join(flowDirPath, flowDirItem);
                      var flowDirItemContext = _node.path.relative(npmDefsDirPath, flowDirItemPath);
                      var flowDirItemStat = _node.fs.statSync(flowDirItemPath);
                      if (flowDirItemStat.isFile()) {
                        if (_node.path.extname(flowDirItem) === '.swp') {
                          return;
                        }

                        // Is this the libdef file?
                        if (flowDirItem === libDefFileName) {
                          libDefFilePath = _node.path.join(flowDirPath, flowDirItem);
                          return;
                        }

                        // Is this a test file?
                        var isValidTestFile = TEST_FILE_NAME_RE.test(flowDirItem);

                        if (isValidTestFile) {
                          testFilePaths.push(flowDirItemPath);
                          return;
                        }

                        var error = "Unexpected file. This directory can only contain test files " + ("or a libdef file named " + ('`' + libDefFileName + '`') + ".");
                        (0, _validationErrors.validationError)(flowDirItemContext, error, validationErrors);
                      } else {
                        var _error2 = "Unexpected sub-directory. This directory can only contain test " + ("files or a libdef file named " + ('`' + libDefFileName + '`') + ".");
                        (0, _validationErrors.validationError)(flowDirItemContext, _error2, validationErrors);
                      }
                    };

                    _context.sent.forEach(_context.t0);

                    if (!(libDefFilePath === null)) {
                      _context.next = 11;
                      break;
                    }

                    libDefFilePath = _node.path.join(flowDirPath, libDefFileName);
                    error = "No libdef file found. Looking for a file named " + libDefFileName;

                    (0, _validationErrors.validationError)(flowDirPath, error, validationErrors);
                    return _context.abrupt("return");

                  case 11:

                    libDefs.push({
                      scope: scope,
                      name: pkgName,
                      version: pkgVersionStr,
                      flowVersion: flowVersion,
                      path: libDefFilePath,
                      testFilePaths: testFilePaths
                    });

                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, null, _this);
          })));

        case 19:
          return _context2.abrupt("return", libDefs);

        case 20:
        case "end":
          return _context2.stop();
      }
    }
  }, null, this);
}

function getCacheNpmLibDefs() {
  return regeneratorRuntime.async(function getCacheNpmLibDefs$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap((0, _cacheRepoUtils.ensureCacheRepo)());

        case 2:
          _context3.next = 4;
          return regeneratorRuntime.awrap((0, _cacheRepoUtils.verifyCLIVersion)());

        case 4:
          return _context3.abrupt("return", getNpmLibDefs(_node.path.join((0, _cacheRepoUtils.getCacheRepoDir)(), 'definitions')));

        case 5:
        case "end":
          return _context3.stop();
      }
    }
  }, null, this);
}

var PKG_NAMEVER_RE = /^(.*)_v\^?([0-9]+)\.([0-9]+|x)\.([0-9]+|x)(-.*)?$/;
function parsePkgNameVer(pkgNameVer, errContext, validationErrors) {
  var pkgNameVerMatches = pkgNameVer.match(PKG_NAMEVER_RE);
  if (pkgNameVerMatches == null) {
    var error = "Malformed npm package name! " + "Expected the name to be formatted as <PKGNAME>_v<MAJOR>.<MINOR>.<PATCH>";
    (0, _validationErrors.validationError)(pkgNameVer, error, validationErrors);
    return null;
  }

  var _pkgNameVerMatches = _slicedToArray(pkgNameVerMatches, 6),
      _ = _pkgNameVerMatches[0],
      pkgName = _pkgNameVerMatches[1],
      major = _pkgNameVerMatches[2],
      minor = _pkgNameVerMatches[3],
      patch = _pkgNameVerMatches[4],
      prerel = _pkgNameVerMatches[5];

  major = validateVersionNumPart(major, "major", errContext, validationErrors);
  minor = validateVersionPart(minor, "minor", errContext, validationErrors);
  patch = validateVersionPart(patch, "patch", errContext, validationErrors);

  if (prerel != null) {
    prerel = prerel.substr(1);
  }

  return { pkgName: pkgName, pkgVersion: { major: major, minor: minor, patch: patch, prerel: prerel } };
}

/**
 * Given a number-or-wildcard part of a version string (i.e. a `minor` or
 * `patch` part), parse the string into either a number or 'x'.
 */
function validateVersionPart(part, partName, context, validationErrs) {
  if (part === "x") {
    return part;
  }
  return validateVersionNumPart(part, partName, context, validationErrs);
}

/**
 * Given a number-only part of a version string (i.e. the `major` part), parse
 * the string into a number.
 */
function validateVersionNumPart(part, partName, context, validationErrs) {
  var num = parseInt(part, 10);
  if (String(num) !== part) {
    var error = "Invalid " + partName + " number: '" + part + "'. Expected a number.";
    (0, _validationErrors.validationError)(context, error, validationErrs);
    return -1;
  }
  return num;
}

function pkgVersionMatch(pkgSemver, libDefSemverRaw) {
  // The package version should be treated as a semver implicitly prefixed by a
  // `^`. (i.e.: "foo_v2.2.x" is the same range as "^2.2.x")
  // UNLESS it is prefixed by the equals character (i.e. "foo_=v2.2.x")
  var libDefSemver = libDefSemverRaw[0] !== '=' && libDefSemverRaw[0] !== '^' ? '^' + libDefSemverRaw : libDefSemverRaw;

  if (_semver3.default.valid(pkgSemver)) {
    // Test the single package version against the LibDef range
    return _semver3.default.satisfies(pkgSemver, libDefSemver);
  }

  if (_semver3.default.valid(libDefSemver)) {
    // Test the single LibDef version against the package range
    return _semver3.default.satisfies(libDefSemver, pkgSemver);
  }

  var pkgRange = new _semver3.default.Range(pkgSemver);
  var libDefRange = new _semver3.default.Range(libDefSemver);

  if (libDefRange.set[0].length !== 2) {
    throw new Error("Invalid npm libdef version! It appears to be a non-continugous range.");
  }

  var libDefLower = (0, _semver.getRangeLowerBound)(libDefRange);
  var libDefUpper = (0, _semver.getRangeUpperBound)(libDefRange);

  var pkgBelowLower = _semver3.default.gtr(libDefLower, pkgSemver);
  var pkgAboveUpper = _semver3.default.ltr(libDefUpper, pkgSemver);
  if (pkgBelowLower || pkgAboveUpper) {
    return false;
  }

  var pkgLower = pkgRange.set[0][0].semver.version;
  return libDefRange.test(pkgLower);
}

function filterLibDefs(defs, filter) {
  return defs.filter(function (def) {
    var filterMatch = false;
    switch (filter.type) {
      case 'exact':
        filterMatch = filter.pkgName.toLowerCase() === def.name.toLowerCase() && pkgVersionMatch(filter.pkgVersion, def.version);
        break;
      default:
        filter;
    }
    if (!filterMatch) {
      return false;
    }

    var filterFlowVersion = filter.flowVersion;
    if (filterFlowVersion !== undefined) {
      var _flowVersion = def.flowVersion;

      switch (_flowVersion.kind) {
        case 'all':
          return true;
        case 'ranged':
        case 'specific':
          return _semver3.default.satisfies((0, _flowVersion2.toSemverString)(filterFlowVersion), (0, _flowVersion2.toSemverString)(def.flowVersion));
        default:
          _flowVersion;
      }
    }

    return true;
  }).sort(function (a, b) {
    var aZeroed = a.version.replace(/x/g, '0');
    var bZeroed = b.version.replace(/x/g, '0');
    return _semver3.default.gt(aZeroed, bZeroed) ? -1 : 1;
  });
}

function findNpmLibDef(pkgName, pkgVersion, flowVersion) {
  var libDefs, filteredLibDefs;
  return regeneratorRuntime.async(function findNpmLibDef$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return regeneratorRuntime.awrap(getCacheNpmLibDefs());

        case 2:
          libDefs = _context4.sent;
          filteredLibDefs = filterLibDefs(libDefs, {
            type: "exact",
            pkgName: pkgName,
            pkgVersion: pkgVersion,
            flowVersion: flowVersion
          });
          return _context4.abrupt("return", filteredLibDefs.length === 0 ? null : filteredLibDefs[0]);

        case 5:
        case "end":
          return _context4.stop();
      }
    }
  }, null, this);
}

function getInstalledNpmLibDefs(flowProjectRootDir) {
  var _this2 = this;

  var libDefDirPath, installedLibDefs, filesInNpmDir;
  return regeneratorRuntime.async(function getInstalledNpmLibDefs$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          libDefDirPath = _node.path.join(flowProjectRootDir, 'flow-typed', 'npm');
          installedLibDefs = new Map();
          _context6.next = 4;
          return regeneratorRuntime.awrap(_node.fs.exists(libDefDirPath));

        case 4:
          if (!_context6.sent) {
            _context6.next = 10;
            break;
          }

          _context6.next = 7;
          return regeneratorRuntime.awrap((0, _fileUtils.getFilesInDir)(libDefDirPath, true));

        case 7:
          filesInNpmDir = _context6.sent;
          _context6.next = 10;
          return regeneratorRuntime.awrap(P.all([].concat(_toConsumableArray(filesInNpmDir)).map(function _callee2(fileName) {
            var fullFilePath, terseFilePath, fileStat, fileContent, signedCodeVer, matches, _scope, nameVer, pkgNameVer, _pkgName, _pkgVersion, flowVerMatches, flowDirStr, context, flowVer;

            return regeneratorRuntime.async(function _callee2$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    fullFilePath = _node.path.join(libDefDirPath, fileName);
                    terseFilePath = _node.path.relative(flowProjectRootDir, fullFilePath);
                    _context5.next = 4;
                    return regeneratorRuntime.awrap(_node.fs.stat(fullFilePath));

                  case 4:
                    fileStat = _context5.sent;

                    if (!fileStat.isFile()) {
                      _context5.next = 32;
                      break;
                    }

                    _context5.next = 8;
                    return regeneratorRuntime.awrap(_node.fs.readFile(fullFilePath));

                  case 8:
                    fileContent = _context5.sent.toString();

                    if (!(0, _codeSign.verifySignedCode)(fileContent)) {
                      _context5.next = 32;
                      break;
                    }

                    signedCodeVer = (0, _codeSign.getSignedCodeVersion)(fileContent);

                    if (!(signedCodeVer === null)) {
                      _context5.next = 13;
                      break;
                    }

                    return _context5.abrupt("return");

                  case 13:
                    matches = signedCodeVer.match(/([^\/]+)\/(@[^\/]+\/)?([^\/]+)\/([^\/]+)/);

                    if (!(matches == null)) {
                      _context5.next = 16;
                      break;
                    }

                    return _context5.abrupt("return");

                  case 16:
                    if (!(matches[1] === "<<STUB>>")) {
                      _context5.next = 19;
                      break;
                    }

                    installedLibDefs.set(terseFilePath, { kind: "Stub", name: matches[2] });
                    return _context5.abrupt("return");

                  case 19:
                    _scope = matches[2] == null ? null : matches[2].substr(0, matches[2].length - 1);
                    nameVer = matches[3];

                    if (!(nameVer === null)) {
                      _context5.next = 23;
                      break;
                    }

                    return _context5.abrupt("return");

                  case 23:
                    pkgNameVer = parsePkgNameVer(nameVer, '', new Map());

                    if (!(pkgNameVer === null)) {
                      _context5.next = 26;
                      break;
                    }

                    return _context5.abrupt("return");

                  case 26:
                    _pkgName = pkgNameVer.pkgName, _pkgVersion = pkgNameVer.pkgVersion;
                    flowVerMatches = matches[4].match(/^flow_(>=|<=)?(v.+)$/);
                    flowDirStr = flowVerMatches == null ? "flow_" + matches[3] : "flow_" + flowVerMatches[2];
                    context = nameVer + "/" + flowDirStr;
                    flowVer = flowVerMatches == null ? (0, _flowVersion2.parseDirString)(flowDirStr, context) : (0, _flowVersion2.parseDirString)(flowDirStr, context);


                    installedLibDefs.set(terseFilePath, { kind: "LibDef", libDef: {
                        scope: _scope,
                        name: _pkgName,
                        version: (0, _semver.versionToString)(_pkgVersion),
                        flowVersion: flowVer,
                        path: terseFilePath,
                        testFilePaths: []
                      } });

                  case 32:
                  case "end":
                    return _context5.stop();
                }
              }
            }, null, _this2);
          })));

        case 10:
          return _context6.abrupt("return", installedLibDefs);

        case 11:
        case "end":
          return _context6.stop();
      }
    }
  }, null, this);
};

/**
 * Retrieve a list of *all* npm libdefs.
 */
function getNpmLibDefs(defsDirPath, validationErrors) {
  var _this3 = this;

  var npmLibDefs, npmDefsDirPath, dirItems;
  return regeneratorRuntime.async(function getNpmLibDefs$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          npmLibDefs = [];
          npmDefsDirPath = _node.path.join(defsDirPath, 'npm');
          _context10.next = 4;
          return regeneratorRuntime.awrap(_node.fs.readdir(npmDefsDirPath));

        case 4:
          dirItems = _context10.sent;
          _context10.next = 7;
          return regeneratorRuntime.awrap(P.all(dirItems.map(function _callee5(itemName) {
            var itemPath, itemStat, libDefs, error;
            return regeneratorRuntime.async(function _callee5$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    itemPath = _node.path.join(npmDefsDirPath, itemName);
                    _context9.next = 3;
                    return regeneratorRuntime.awrap(_node.fs.stat(itemPath));

                  case 3:
                    itemStat = _context9.sent;

                    if (!itemStat.isDirectory()) {
                      _context9.next = 16;
                      break;
                    }

                    if (!(itemName[0] === '@')) {
                      _context9.next = 10;
                      break;
                    }

                    _context9.next = 8;
                    return regeneratorRuntime.awrap(function _callee4() {
                      var scope, scopeDirItems;
                      return regeneratorRuntime.async(function _callee4$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              // This must be a scoped npm package, so go one directory deeper
                              scope = itemName;
                              _context8.next = 3;
                              return regeneratorRuntime.awrap(_node.fs.readdir(itemPath));

                            case 3:
                              scopeDirItems = _context8.sent;
                              _context8.next = 6;
                              return regeneratorRuntime.awrap(P.all(scopeDirItems.map(function _callee3(itemName) {
                                var itemPath, itemStat, libDefs, error;
                                return regeneratorRuntime.async(function _callee3$(_context7) {
                                  while (1) {
                                    switch (_context7.prev = _context7.next) {
                                      case 0:
                                        itemPath = _node.path.join(npmDefsDirPath, scope, itemName);
                                        _context7.next = 3;
                                        return regeneratorRuntime.awrap(_node.fs.stat(itemPath));

                                      case 3:
                                        itemStat = _context7.sent;

                                        if (!itemStat.isDirectory()) {
                                          _context7.next = 11;
                                          break;
                                        }

                                        _context7.next = 7;
                                        return regeneratorRuntime.awrap(extractLibDefsFromNpmPkgDir(itemPath, scope, itemName, validationErrors));

                                      case 7:
                                        libDefs = _context7.sent;

                                        libDefs.forEach(function (libDef) {
                                          return npmLibDefs.push(libDef);
                                        });
                                        _context7.next = 13;
                                        break;

                                      case 11:
                                        error = "Expected only sub-directories in this dir!";

                                        (0, _validationErrors.validationError)(itemPath, error, validationErrors);

                                      case 13:
                                      case "end":
                                        return _context7.stop();
                                    }
                                  }
                                }, null, _this3);
                              })));

                            case 6:
                            case "end":
                              return _context8.stop();
                          }
                        }
                      }, null, _this3);
                    }());

                  case 8:
                    _context9.next = 14;
                    break;

                  case 10:
                    _context9.next = 12;
                    return regeneratorRuntime.awrap(extractLibDefsFromNpmPkgDir(itemPath, null, // No scope
                    itemName, validationErrors));

                  case 12:
                    libDefs = _context9.sent;

                    libDefs.forEach(function (libDef) {
                      return npmLibDefs.push(libDef);
                    });

                  case 14:
                    _context9.next = 18;
                    break;

                  case 16:
                    error = "Expected only directories to be present in this directory.";

                    (0, _validationErrors.validationError)(itemPath, error, validationErrors);

                  case 18:
                  case "end":
                    return _context9.stop();
                }
              }
            }, null, _this3);
          })));

        case 7:
          return _context10.abrupt("return", npmLibDefs);

        case 8:
        case "end":
          return _context10.stop();
      }
    }
  }, null, this);
};

function getNpmLibDefVersionHash(repoDirPath, libDef) {
  var latestCommitHash;
  return regeneratorRuntime.async(function getNpmLibDefVersionHash$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.next = 2;
          return regeneratorRuntime.awrap((0, _git.findLatestFileCommitHash)(repoDirPath, _node.path.relative(repoDirPath, libDef.path)));

        case 2:
          latestCommitHash = _context11.sent;
          return _context11.abrupt("return", latestCommitHash.substr(0, 10) + "/" + (libDef.scope === null ? '' : libDef.scope + "/") + (libDef.name + "_" + libDef.version + "/") + ("flow_" + (0, _flowVersion2.toSemverString)(libDef.flowVersion)));

        case 4:
        case "end":
          return _context11.stop();
      }
    }
  }, null, this);
};

exports._extractLibDefsFromNpmPkgDir = extractLibDefsFromNpmPkgDir;
exports._parsePkgNameVer = parsePkgNameVer;
exports._validateVersionNumPart = validateVersionNumPart;
exports._validateVersionPart = validateVersionPart;