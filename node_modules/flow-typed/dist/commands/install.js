"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._installNpmLibDef = exports._installNpmLibDefs = exports._determineFlowVersion = exports.description = exports.name = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.setup = setup;
exports.run = run;

var _codeSign = require("../lib/codeSign");

var _fileUtils = require("../lib/fileUtils");

var _flowProjectUtils = require("../lib/flowProjectUtils");

var _flowVersion = require("../lib/flowVersion");

var _node = require("../lib/node");

var _npmLibDefs = require("../lib/npm/npmLibDefs");

var _npmProjectUtils = require("../lib/npm/npmProjectUtils");

var _cacheRepoUtils = require("../lib/cacheRepoUtils");

var _semver = require("../lib/semver");

var _safe = require("colors/safe");

var _safe2 = _interopRequireDefault(_safe);

var _semver2 = require("semver");

var _semver3 = _interopRequireDefault(_semver2);

var _stubUtils = require("../lib/stubUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var name = exports.name = "install";
var description = exports.description = "Installs libdefs into the ./flow-typed directory";
function setup(yargs) {
  return yargs.usage("$0 " + name + " - " + description).options({
    flowVersion: {
      alias: 'f',
      describe: "The Flow version that fetched libdefs must be compatible " + "with",
      type: "string"
    },
    verbose: {
      describe: "Print additional, verbose info while installing libdefs",
      type: "boolean",
      demand: false
    }
  });
};
function run(args) {
  var cwd, flowVersion, explicitLibDefs, coreLibDefResult, npmLibDefResult;
  return regeneratorRuntime.async(function run$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          cwd = process.cwd();
          _context.next = 3;
          return regeneratorRuntime.awrap(determineFlowVersion(cwd, args.flowVersion));

        case 3:
          flowVersion = _context.sent;
          explicitLibDefs = args._.slice(1);
          _context.next = 7;
          return regeneratorRuntime.awrap(installCoreLibDefs());

        case 7:
          coreLibDefResult = _context.sent;

          if (!(coreLibDefResult !== 0)) {
            _context.next = 10;
            break;
          }

          return _context.abrupt("return", coreLibDefResult);

        case 10:
          _context.next = 12;
          return regeneratorRuntime.awrap(installNpmLibDefs({
            cwd: cwd,
            flowVersion: flowVersion,
            explicitLibDefs: explicitLibDefs,
            verbose: args.verbose,
            overwrite: args.overwrite
          }));

        case 12:
          npmLibDefResult = _context.sent;

          if (!(npmLibDefResult !== 0)) {
            _context.next = 15;
            break;
          }

          return _context.abrupt("return", npmLibDefResult);

        case 15:
          return _context.abrupt("return", 0);

        case 16:
        case "end":
          return _context.stop();
      }
    }
  }, null, this);
};

function determineFlowVersion(cwd, flowVersionArg) {
  var flowVersionStr;
  return regeneratorRuntime.async(function determineFlowVersion$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(flowVersionArg != null)) {
            _context2.next = 6;
            break;
          }

          // Be permissive if the prefix 'v' is left off
          flowVersionStr = flowVersionArg[0] === 'v' ? flowVersionArg : "v" + flowVersionArg;


          if (/^v[0-9]+\.[0-9]+$/.test(flowVersionStr)) {
            flowVersionStr = flowVersionStr + ".0";
          }

          return _context2.abrupt("return", {
            kind: 'specific',
            ver: (0, _flowVersion.parseFlowSpecificVer)(flowVersionStr, flowVersionArg)
          });

        case 6:
          _context2.next = 8;
          return regeneratorRuntime.awrap((0, _npmProjectUtils.findFlowSpecificVer)(cwd, cwd));

        case 8:
          _context2.t0 = _context2.sent;
          return _context2.abrupt("return", {
            kind: 'specific',
            ver: _context2.t0
          });

        case 10:
        case "end":
          return _context2.stop();
      }
    }
  }, null, this);
}

function installCoreLibDefs() {
  return regeneratorRuntime.async(function installCoreLibDefs$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          return _context3.abrupt("return", 0);

        case 1:
        case "end":
          return _context3.stop();
      }
    }
  }, null, this);
}

var FLOW_BUILT_IN_NPM_LIBS = ['react', 'react-dom'];

function installNpmLibDefs(_ref) {
  var _this = this;

  var cwd = _ref.cwd,
      flowVersion = _ref.flowVersion,
      explicitLibDefs = _ref.explicitLibDefs,
      verbose = _ref.verbose,
      overwrite = _ref.overwrite;

  var flowProjectRoot, libdefsToSearchFor, i, term, termMatches, _termMatches, _2, npmScope, pkgName, pkgVerStr, scopedPkgName, pkgJsonData, pkgJsonDeps, libDefsToSearchForEntries, libDefsToInstall, outdatedLibDefsToInstall, unavailableLibDefs, libDefsToUninstall, alreadyInstalledLibDefs, _ret;

  return regeneratorRuntime.async(function installNpmLibDefs$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          _context10.next = 2;
          return regeneratorRuntime.awrap((0, _flowProjectUtils.findFlowRoot)(cwd));

        case 2:
          flowProjectRoot = _context10.sent;

          if (!(flowProjectRoot === null)) {
            _context10.next = 6;
            break;
          }

          console.error("Error: Unable to find a flow project in the current dir or any of " + "it's parent dirs!\n" + "Please run this command from within a Flow project.");
          return _context10.abrupt("return", 1);

        case 6:
          libdefsToSearchFor = new Map();

          // If a specific pkg/version was specified, only add those packages.
          // Otherwise, extract dependencies from the package.json

          if (!(explicitLibDefs.length > 0)) {
            _context10.next = 24;
            break;
          }

          i = 0;

        case 9:
          if (!(i < explicitLibDefs.length)) {
            _context10.next = 21;
            break;
          }

          term = explicitLibDefs[i];
          termMatches = term.match(/(@[^@\/]+\/)?([^@]+)@(.+)/);

          if (!(termMatches == null)) {
            _context10.next = 15;
            break;
          }

          console.error("ERROR: Please specify npm package names in the format of `foo@1.2.3`");
          return _context10.abrupt("return", 1);

        case 15:
          _termMatches = _slicedToArray(termMatches, 4), _2 = _termMatches[0], npmScope = _termMatches[1], pkgName = _termMatches[2], pkgVerStr = _termMatches[3];
          scopedPkgName = npmScope != null ? npmScope + pkgName : pkgName;

          libdefsToSearchFor.set(scopedPkgName, pkgVerStr);

        case 18:
          i++;
          _context10.next = 9;
          break;

        case 21:
          console.log("\u2022 Searching for " + libdefsToSearchFor.size + " libdefs...");
          _context10.next = 33;
          break;

        case 24:
          _context10.next = 26;
          return regeneratorRuntime.awrap((0, _npmProjectUtils.getPackageJsonData)(cwd));

        case 26:
          pkgJsonData = _context10.sent;
          pkgJsonDeps = (0, _npmProjectUtils.getPackageJsonDependencies)(pkgJsonData);

          for (pkgName in pkgJsonDeps) {
            libdefsToSearchFor.set(pkgName, pkgJsonDeps[pkgName]);
          }

          if (!(libdefsToSearchFor.size === 0)) {
            _context10.next = 32;
            break;
          }

          console.error("No dependencies were found in this project's package.json!");
          return _context10.abrupt("return", 1);

        case 32:

          if (verbose) {
            libdefsToSearchFor.forEach(function (ver, name) {
              console.log("\u2022 Found package.json dependency: " + name + "@" + ver);
            });
          } else {
            console.log("\u2022 Found " + libdefsToSearchFor.size + " dependencies in package.json to " + "install libdefs for. Searching...");
          }

        case 33:
          libDefsToSearchForEntries = [].concat(_toConsumableArray(libdefsToSearchFor.entries()));

          // Search for the requested libdefs

          libDefsToInstall = new Map();
          outdatedLibDefsToInstall = [];
          unavailableLibDefs = [];
          _context10.next = 39;
          return regeneratorRuntime.awrap(Promise.all(libDefsToSearchForEntries.map(function _callee(_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
                name = _ref3[0],
                ver = _ref3[1];

            var libDef, libDefLower, depLower;
            return regeneratorRuntime.async(function _callee$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(FLOW_BUILT_IN_NPM_LIBS.indexOf(name) !== -1)) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt("return");

                  case 2:
                    _context4.next = 4;
                    return regeneratorRuntime.awrap((0, _npmLibDefs.findNpmLibDef)(name, ver, flowVersion));

                  case 4:
                    libDef = _context4.sent;

                    if (libDef === null) {
                      unavailableLibDefs.push({ name: name, ver: ver });
                    } else {
                      libDefsToInstall.set(name, libDef);

                      // If the libdef is outdated (but still compatible), note this so we can
                      // warn the user
                      libDefLower = (0, _semver.getRangeLowerBound)(libDef.version);
                      depLower = (0, _semver.getRangeLowerBound)(ver);

                      if (_semver3.default.lt(libDefLower, depLower)) {
                        outdatedLibDefsToInstall.push([libDef, { name: name, ver: ver }]);
                      }
                    }

                  case 6:
                  case "end":
                    return _context4.stop();
                }
              }
            }, null, _this);
          })));

        case 39:

          // Scan libdefs that are already installed
          libDefsToUninstall = new Map();
          _context10.next = 42;
          return regeneratorRuntime.awrap((0, _npmLibDefs.getInstalledNpmLibDefs)(_node.path.join(flowProjectRoot)));

        case 42:
          alreadyInstalledLibDefs = _context10.sent;

          [].concat(_toConsumableArray(alreadyInstalledLibDefs.entries())).forEach(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
                filePath = _ref5[0],
                npmLibDef = _ref5[1];

            var fullFilePath = _node.path.join(flowProjectRoot, filePath);
            switch (npmLibDef.kind) {
              case 'LibDef':
                // If a libdef is already installed for some dependency, we need to
                // uninstall it before installing the new (potentially updated) ver
                var libDef = npmLibDef.libDef;
                //const toInstall = libDefsToInstall.has(libDef.name);
                //console.log(`Found ${libDef.name} already installed. Uninstall? ${toInstall != null ? 'yes' : 'no'}`);
                if (libDefsToInstall.has(libDef.name)) {
                  libDefsToUninstall.set(libDef.name, fullFilePath);
                }
                break;

              case 'Stub':
                break;

              default:
                npmLibDef;
            }
          });

          if (!(libDefsToInstall.size > 0)) {
            _context10.next = 50;
            break;
          }

          _context10.next = 47;
          return regeneratorRuntime.awrap(function _callee3() {
            var flowTypedDirPath, results;
            return regeneratorRuntime.async(function _callee3$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    console.log("\u2022 Installing " + libDefsToInstall.size + " libDefs...");
                    flowTypedDirPath = _node.path.join(flowProjectRoot, 'flow-typed', 'npm');
                    _context6.next = 4;
                    return regeneratorRuntime.awrap((0, _fileUtils.mkdirp)(flowTypedDirPath));

                  case 4:
                    _context6.next = 6;
                    return regeneratorRuntime.awrap(Promise.all([].concat(_toConsumableArray(libDefsToInstall.values())).map(function _callee2(def) {
                      var toUninstall;
                      return regeneratorRuntime.async(function _callee2$(_context5) {
                        while (1) {
                          switch (_context5.prev = _context5.next) {
                            case 0:
                              toUninstall = libDefsToUninstall.get(def.name);

                              if (!(toUninstall != null)) {
                                _context5.next = 4;
                                break;
                              }

                              _context5.next = 4;
                              return regeneratorRuntime.awrap(_node.fs.unlink(toUninstall));

                            case 4:
                              return _context5.abrupt("return", installNpmLibDef(def, flowTypedDirPath, overwrite));

                            case 5:
                            case "end":
                              return _context5.stop();
                          }
                        }
                      }, null, _this);
                    })));

                  case 6:
                    results = _context6.sent;

                    if (!results.some(function (res) {
                      return !res;
                    })) {
                      _context6.next = 9;
                      break;
                    }

                    return _context6.abrupt("return", {
                      v: 1
                    });

                  case 9:
                  case "end":
                    return _context6.stop();
                }
              }
            }, null, _this);
          }());

        case 47:
          _ret = _context10.sent;

          if (!((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object")) {
            _context10.next = 50;
            break;
          }

          return _context10.abrupt("return", _ret.v);

        case 50:

          if ((verbose || unavailableLibDefs.length === 0) && outdatedLibDefsToInstall.length > 0) {
            console.log("• The following installed libdefs are compatible with your " + "dependencies, but may not include all minor and patch changes for " + "your specific dependency version:\n");
            outdatedLibDefsToInstall.forEach(function (_ref6) {
              var _ref7 = _slicedToArray(_ref6, 2),
                  libDef = _ref7[0],
                  _ref7$ = _ref7[1],
                  pkgName = _ref7$.name,
                  pkgVersion = _ref7$.ver;

              console.log("  • libdef: %s (satisfies %s)", _safe2.default.yellow(libDef.name + "_" + libDef.version), _safe2.default.bold(pkgName + "@" + pkgVersion));

              var libDefPlural = outdatedLibDefsToInstall.length > 1 ? ["versioned updates", "these packages"] : ["a versioned update", "this package"];
              console.log("\n" + ("  Consider submitting " + libDefPlural[0] + " for " + libDefPlural[1] + " to \n") + "  https://github.com/flowtype/flow-typed/\n");
            });
          }

          if (!(unavailableLibDefs.length > 0 && unavailableLibDefs.length === explicitLibDefs.length)) {
            _context10.next = 56;
            break;
          }

          // If the user specified an explicit library to be installed, don't generate
          // a stub if no libdef exists -- just inform them that one doesn't exist
          console.log(_safe2.default.red("!! No libdefs found in flow-typed for the explicitly requested libdefs. !!") + "\n" + "\n" + "Consider using `%s` to generate an empty libdef that you can fill in.", _safe2.default.bold("flow-typed create-stub " + explicitLibDefs.join(' ')));

          return _context10.abrupt("return", 1);

        case 56:
          _context10.next = 58;
          return regeneratorRuntime.awrap(function _callee6() {
            var untypedMissingLibDefs, typedMissingLibDefs, plural;
            return regeneratorRuntime.async(function _callee6$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    // If a package that's missing a flow-typed libdef has any .flow files,
                    // we'll skip generating a stub for it.
                    untypedMissingLibDefs = [];
                    typedMissingLibDefs = [];
                    _context9.next = 4;
                    return regeneratorRuntime.awrap(Promise.all(unavailableLibDefs.map(function _callee4(_ref8) {
                      var pkgName = _ref8.name,
                          pkgVer = _ref8.ver;
                      var hasFlowFiles;
                      return regeneratorRuntime.async(function _callee4$(_context7) {
                        while (1) {
                          switch (_context7.prev = _context7.next) {
                            case 0:
                              _context7.next = 2;
                              return regeneratorRuntime.awrap((0, _stubUtils.pkgHasFlowFiles)(cwd, pkgName));

                            case 2:
                              hasFlowFiles = _context7.sent;

                              if (hasFlowFiles) {
                                typedMissingLibDefs.push([pkgName, pkgVer]);
                              } else {
                                untypedMissingLibDefs.push([pkgName, pkgVer]);
                              }

                            case 4:
                            case "end":
                              return _context7.stop();
                          }
                        }
                      }, null, _this);
                    })));

                  case 4:
                    if (!(untypedMissingLibDefs.length > 0)) {
                      _context9.next = 11;
                      break;
                    }

                    console.log('• Generating stubs for untyped dependencies...');
                    _context9.next = 8;
                    return regeneratorRuntime.awrap(Promise.all(untypedMissingLibDefs.map(function _callee5(_ref9) {
                      var _ref10 = _slicedToArray(_ref9, 2),
                          pkgName = _ref10[0],
                          pkgVerStr = _ref10[1];

                      return regeneratorRuntime.async(function _callee5$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              _context8.next = 2;
                              return regeneratorRuntime.awrap((0, _stubUtils.createStub)(flowProjectRoot, pkgName, pkgVerStr, true));

                            case 2:
                            case "end":
                              return _context8.stop();
                          }
                        }
                      }, null, _this);
                    })));

                  case 8:

                    console.log(_safe2.default.red("\n!! No flow@" + (0, _flowVersion.toSemverString)(flowVersion) + "-compatible libdefs " + "found in flow-typed for the above untyped dependencies !!"));

                    plural = unavailableLibDefs.length > 1 ? ['libdefs', 'these packages', 'them'] : ['a libdef', 'this package', 'it'];

                    console.log("\n" + ("I've generated " + '`' + "any" + '`' + "-typed stubs for " + plural[1] + ", but ") + "consider submitting \n" + (plural[0] + " for " + plural[2] + " to ") + (_safe2.default.bold('https://github.com/flowtype/flow-typed/') + "\n"));

                  case 11:
                  case "end":
                    return _context9.stop();
                }
              }
            }, null, _this);
          }());

        case 58:
          return _context10.abrupt("return", 0);

        case 59:
        case "end":
          return _context10.stop();
      }
    }
  }, null, this);
}

function installNpmLibDef(npmLibDef, npmDir, overwrite) {
  var scopedDir, fileName, filePath, terseFilePath, repoVersion, codeSignPreprocessor;
  return regeneratorRuntime.async(function installNpmLibDef$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          scopedDir = npmLibDef.scope === null ? npmDir : _node.path.join(npmDir, npmLibDef.scope);

          (0, _fileUtils.mkdirp)(scopedDir);

          fileName = npmLibDef.name + "_" + npmLibDef.version + ".js";
          filePath = _node.path.join(scopedDir, fileName);

          // Find the libDef in the cached repo

          _context11.prev = 4;
          terseFilePath = _node.path.relative(_node.path.resolve(npmDir, '..', '..'), filePath);
          _context11.t0 = !overwrite;

          if (!_context11.t0) {
            _context11.next = 11;
            break;
          }

          _context11.next = 10;
          return regeneratorRuntime.awrap(_node.fs.exists(filePath));

        case 10:
          _context11.t0 = _context11.sent;

        case 11:
          if (!_context11.t0) {
            _context11.next = 14;
            break;
          }

          console.error("  • %s\n" + "    └> %s", _safe2.default.bold(_safe2.default.red(terseFilePath + " already exists and appears to have been manually " + "written or changed!")), "Use --overwrite to overwrite the existing libdef.");
          return _context11.abrupt("return", true);

        case 14:
          _context11.next = 16;
          return regeneratorRuntime.awrap((0, _npmLibDefs.getNpmLibDefVersionHash)((0, _cacheRepoUtils.getCacheRepoDir)(), npmLibDef));

        case 16:
          repoVersion = _context11.sent;
          codeSignPreprocessor = (0, _codeSign.signCodeStream)(repoVersion);
          _context11.next = 20;
          return regeneratorRuntime.awrap((0, _fileUtils.copyFile)(npmLibDef.path, filePath, codeSignPreprocessor));

        case 20:

          console.log(_safe2.default.bold("  • %s\n" + "    └> %s"), fileName, _safe2.default.green("." + _node.path.sep + terseFilePath));

          return _context11.abrupt("return", true);

        case 24:
          _context11.prev = 24;
          _context11.t1 = _context11["catch"](4);

          console.error("  !! Failed to install " + npmLibDef.name + " at " + filePath);
          console.error("  ERROR: " + _context11.t1.message);
          return _context11.abrupt("return", false);

        case 29:
        case "end":
          return _context11.stop();
      }
    }
  }, null, this, [[4, 24]]);
}

exports._determineFlowVersion = determineFlowVersion;
exports._installNpmLibDefs = installNpmLibDefs;
exports._installNpmLibDef = installNpmLibDef;